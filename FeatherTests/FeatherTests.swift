//
//  FeatherTests.swift
//  FeatherTests
//
//  Created by Lakhan Lothiyi on 19/04/2025.
//

import XCTest
@testable import Feather
@testable import Esign
 
final class FeatherTests: XCTestCase {

//	override func setUpWithError() throws {
//		// Put setup code here. This method is called before the invocation of each test method in the class.
//	}
//
//	override func tearDownWithError() throws {
//		// Put teardown code here. This method is called after the invocation of each test method in the class.
//	}
//
//	func testExample() throws {
//		// This is an example of a functional test case.
//		// Use XCTAssert and related functions to verify your tests produce the correct results.
//		// Any test you write for XCTest can be annotated as throws and async.
//		// Mark your test throws to produce an unexpected failure when your test encounters an uncaught error.
//		// Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards.
//		
//	}
//
//	func testPerformanceExample() throws {
//		// This is an example of a performance test case.
//		measure {
//			// Put the code you want to measure the time of here.
//		}
//	}

	func testRepoParsing() async throws {
		let repoDatas: [URL: Data] = try await withThrowingTaskGroup(of: (URL,Data).self, returning: [URL : Data].self) { group in
			for url in repoURLs {
				group.addTask {
					let (data, _) = try await URLSession.shared.data(from: url)
					return (url, data)
				}
			}
			
			var results: [URL: Data] = [:]
			for try await result in group {
				results[result.0] = result.1
			}
			
			return results
		}
		
		let decoder = JSONDecoder()
		let dateFormatter = DateFormatter()
		dateFormatter.dateFormat = "yyyy-MM-dd"
		decoder.dateDecodingStrategy = .formatted(dateFormatter)
		
		var accumulated: [Repository] = []
		for (url, data) in repoDatas {
			do {
				let repo = try decoder.decode(Repository.self, from: data)
				accumulated.append(repo)
			} catch {
				XCTFail("Failed to decode repo data: \(error)\n\nFailed for \(url)\n\n======================================\n\n")
			}
		}
		
		print("\(accumulated.count) repositories")
		for repo in accumulated {
			print("\(repo.name) (\(repo.apps.count) apps)")
			
		}
	}
	
	func testRepoDeobfuscation() async throws  {
		// theres multiple ways to obfuscate a list of strings, base64, other encryption, etc.
		// kravasign/maplesign use plain base64 to export repository "codes", newlines seperated
		// by `[K$]` and or `[M$]` (depending on what app you're currently using)
		
		// on the other hand Easy Sign (Esign) obfuscate their repository codes using more than
		// base64, stupidly complicated but they do use some obfuscation key and technique
		
		// we need to handle both cases, base64 and the latter, first we can check if whats
		// pasted starts with `source[`, then go from there. All we need is a list of repositories
		// seperated with newlines.
		
		let code = obfuscatedKUrl
		
		func decodeBase64Format(_ code: String) -> Result<[String], RepositoryDeobfuscationError> {
			guard
				let data = Data(base64Encoded: code),
				let decodedString = String(data: data, encoding: .utf8)
			else {
				return .failure(.base64DecodingFailure)
			}
			
			var repositories: [String]
			if decodedString.contains("[K$]") {
				repositories = decodedString.components(separatedBy: "[K$]")
			} else if decodedString.contains("[M$]") {
				repositories = decodedString.components(separatedBy: "[M$]")
			} else {
				repositories = decodedString.components(separatedBy: .newlines)
			}
			
			repositories = repositories.map {
				$0.trimmingCharacters(in: .whitespacesAndNewlines)
			}.filter { !$0.isEmpty }
			
			print(repositories)
			
			return repositories.isEmpty
			? .failure(.emptyResult)
			: .success(repositories)
		}
		
		let trimmedCode = code.trimmingCharacters(in: .whitespacesAndNewlines)
		
		// Empty input check
		guard !trimmedCode.isEmpty else {
			return
		}
		
		if trimmedCode.hasPrefix("source[") {
			let c = eRepoDecrypt(input: code)
			print(c.decrypt() ?? [])
			return
		} else {
			_ = decodeBase64Format(trimmedCode)
			return
		}
	}
	
	func testRepositoryUpdateFunctionality() async throws {
		// Test that the SourcesViewModel can be initialized
		let viewModel = SourcesViewModel.shared
		XCTAssertNotNil(viewModel)
		
		// Test that the view model starts with empty sources
		XCTAssertTrue(viewModel.sources.isEmpty)
		XCTAssertTrue(viewModel.lastUpdated.isEmpty)
		
		// Test UserDefaults keys for repository settings
		let autoRefreshKey = "Feather.autoRefreshRepositories"
		let autoRefreshOnLaunchKey = "Feather.autoRefreshOnLaunch"
		let lastAutoRefreshKey = "Feather.lastAutoRepositoryRefresh"
		let lastManualRefreshKey = "Feather.lastManualRepositoryUpdate"
		
		// Set test values
		UserDefaults.standard.set(true, forKey: autoRefreshKey)
		UserDefaults.standard.set(true, forKey: autoRefreshOnLaunchKey)
		UserDefaults.standard.set(Date(), forKey: lastAutoRefreshKey)
		UserDefaults.standard.set(Date(), forKey: lastManualRefreshKey)
		
		// Verify values can be read
		XCTAssertTrue(UserDefaults.standard.bool(forKey: autoRefreshKey))
		XCTAssertTrue(UserDefaults.standard.bool(forKey: autoRefreshOnLaunchKey))
		XCTAssertNotNil(UserDefaults.standard.object(forKey: lastAutoRefreshKey))
		XCTAssertNotNil(UserDefaults.standard.object(forKey: lastManualRefreshKey))
		
		// Clean up test data
		UserDefaults.standard.removeObject(forKey: autoRefreshKey)
		UserDefaults.standard.removeObject(forKey: autoRefreshOnLaunchKey)
		UserDefaults.standard.removeObject(forKey: lastAutoRefreshKey)
		UserDefaults.standard.removeObject(forKey: lastManualRefreshKey)
	}
	
	func testRepositoryUpdateInterval() {
		// Test that refresh intervals are calculated correctly
		let oneHour: TimeInterval = 60 * 60
		let fourHours: TimeInterval = 4 * 60 * 60
		
		let now = Date()
		let oneHourAgo = now.addingTimeInterval(-oneHour)
		let fourHoursAgo = now.addingTimeInterval(-fourHours)
		
		// Test that one hour interval is correct
		XCTAssertGreaterThan(now.timeIntervalSince(oneHourAgo), oneHour - 1)
		XCTAssertLessThan(now.timeIntervalSince(oneHourAgo), oneHour + 1)
		
		// Test that four hour interval is correct
		XCTAssertGreaterThan(now.timeIntervalSince(fourHoursAgo), fourHours - 1)
		XCTAssertLessThan(now.timeIntervalSince(fourHoursAgo), fourHours + 1)
	}
}

// these are quite interesting.
let obfuscatedKUrl = "aHR0cHM6Ly9jZG4uYWx0c3RvcmUuaW8vZmlsZS9hbHRzdG9yZS9hcHBzLmpzb24="
let obfEUrl = "source[5GHxhb1U7Lc5jIMpumASbN2teg9dyK5EAazzwnfm1/gPKQPTWzcz/Gq3Njt97KapLNMztZCR3sHbMw/AMSpBsztQijHaOP/HgNtFseMyB1U=]"

let repoURLs: [URL] = [
	"https://cdn.altstore.io/file/altstore/apps.json",
].map { URL(string: $0)! }

enum RepositoryDeobfuscationError: Error {
	case invalidFormat
	case esignDecodingFailure
	case base64DecodingFailure
	case emptyResult
}
